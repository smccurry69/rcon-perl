#!/usr/bin/perl
#
# rcon-perl v0.0c
# 2015-07-14


# TODO: passing filehandles
# TODO: exit cleanly

use strict;
use Socket;
use IO::Socket::INET;
use POSIX qw(EWOULDBLOCK EINTR);

#use Term::ReadKey;

# for IO::Select stdin non blocking
use IO::Handle;
use IO::Select;


################################################
#
# CONFIGURATION
#
# IP / Port and/or Password here if you want to hard code it
#
################################################

my $host_ip = "";
my $host_port = "";
my $rcon_password = "";

################################################
# Other settings
################################################

my $ansi_enabled = 0;
my $logging_enabled = 1;
my $logging_timestamp_enabled = 1;
my $console_timestamp_enabled = 1;
my $logfilename = "~/rcon-perl.log";
my $debug_enabled = 0;
my $retry_timeout = 30;
################################################

# colors
 my %ansi;
 $ansi{'left'}          ="\e[D";
 $ansi{'reverse'}	="\e[7m";
 $ansi{'normal'}	="\e[0m";
 $ansi{'black'}		="\e[0;30m";
 $ansi{'hblack'}	="\e[1;30m";
 $ansi{'red'}		="\e[0;31m";
 $ansi{'hred'}		="\e[1;31m";
 $ansi{'green'}		="\e[0;32m";
 $ansi{'hgreen'}	="\e[1;32m";
 $ansi{'yellow'}	="\e[0;33m";
 $ansi{'hyellow'}	="\e[1;33m";
 $ansi{'blue'}		="\e[0;34m";
 $ansi{'hblue'}		="\e[1;34m";
 $ansi{'magenta'}	="\e[0;35m";
 $ansi{'hmagenta'}	="\e[1;35m";
 $ansi{'cyan'}		="\e[0;36m";
 $ansi{'hcyan'}		="\e[1;36m";
 $ansi{'white'}		="\e[0;37m";
 $ansi{'hwhite'}	="\e[1;37m";



# buffer flushing
$| = 1;

my $inbuffer = "";
my $user_input_buffer = "";
my $rcon_logged_in = 0;
my $client_connected = 0;
my $login_timer = 0; #timer for auth

#nonblocking input handle
my $nb_stdin = new IO::Select( *STDIN );

my $socket; # socket handle
my $logfilefh; #log file handle

# make sure we have a hostname, etc
load_config();


if ($logging_enabled == 1) {
	if (open $logfilefh, ">>", $logfilename) {
		printcolor("- Started logging to $logfilename\n");
	}
	else {
		$logging_enabled = 0;
		printcolor("- Failed to open '$logfilename' for append.  Logging disabled.\n","red");
	}
}




# MAIN LOOP
while (1) {

	#if disconnected, connect
	while ($client_connected == 0) {
		# start the connection
		client_connect();
		rcon_login();
		$login_timer = 0;
	}

	if ($rcon_logged_in == 0) {
		if ($login_timer < 20) {
			$login_timer++;
		}
		else {
			$login_timer = 0;
			logandprint("No login within time limit.  Retrying.\n");
			client_disconnect();
			sleep 1;
		}
	}


	# Get any data from the server and process it
	process_server_messages();

	# Deal with user inputs
	process_user_input();

	# Sleep a quarter second
	select(undef, undef, undef, 0.25);


}


sub load_config {

	if ($host_ip eq "" || $host_port eq "") {
		if ($ARGV[0] eq "" || $ARGV[1] eq "") {
			print "Usage: $0 hostname portnumber\n";
			exit;
		}
		else {
			$host_ip = $ARGV[0];
			$host_port = $ARGV[1];
			if ($ARGV[2] ne "") {
				$rcon_password = $ARGV[2];
				print "Using password '".$rcon_password." from the command line.  Generally this is unsafe.\n";
			}
		}
	}


	if ($rcon_password eq "") {
		print "RCON Password:";
		$rcon_password = <STDIN>;
		chomp($rcon_password); #get rid of carriage return from input
	}

	#expand any home directories ie ~ in $logfilename
	$logfilename=cleanupfilename($logfilename);
	

}

#TODO: fix this to be more correct
#expand any leading tilde or other cleanup here
sub cleanupfilename {
	my $filename = shift;
	my $username = getpwuid( $< );
	#handle ~/
	$filename =~ s/^~\//\/home\/$username\//;
	#handle ~username/
	$filename =~ s/^~([^\/]*)/\/home\/$1/;
	return $filename;
}
		
sub client_connect {
	while ($client_connected == 0) {
		socket_connect();
		$client_connected = check_client_connected();
		if ($client_connected == 0)
		{
			logandprint( "- Connection failed.  Retrying in $retry_timeout seconds.\n","red");
			sleep $retry_timeout;
		}

	}
	$rcon_logged_in = 0;
	logandprint ("- Connection established\n");
}


sub socket_connect {
	logandprint ("- Opening connection to host '$host_ip' port '$host_port'.\n");
	 $socket = IO::Socket::INET->new(PeerAddr => $host_ip,
                                 PeerPort => $host_port,
                                 Proto    => 'tcp',
				 Blocking => 0)
	 or die "Can't start the connection.\n";

	sleep 1;
	if ($socket->connected) {
		$client_connected = 1;
		return;
	}
	logandprint ("- Waiting on connection\n");
	sleep 5;
	if ($socket->connected) {
		$client_connected = 1;
		return;
	} else {
		logandprint ("- No connection\n");
	}


}

# server_disconnected
# - called when disconnection was detected
sub handle_client_disconnected 
{
	logandprint ("- Server Disconnected\n", "red");
	$client_connected = 0 ;
	socket_disconnect();
}

# client_disconnect
# - called when we want to initiate a disconnect
sub client_disconnect {
	socket_disconnect();
	$client_connected = 0;
	logandprint ("Closing connection.\n");
}




sub socket_disconnect {
	shutdown($socket, 2) if $socket;
	close($socket) if $socket;
}

sub check_client_connected {
	my $sockhandle = $socket;
	#my $byteswritten="";
	#$byteswritten = syswrite ($sockhandle, "", 0);
	#if (defined $byteswritten) {
#		print "false";
#		return 0;
#	}
#	else {
#		print "true";
#		return 1;
#	}
	if ($sockhandle->connected) {
		return 1;
	}
	return 0;
}



sub rcon_login {
	logandprint ("- Sending RCON Password\n");
	# RCON LOGIN
	sleep 1;
	sendauth ($rcon_password,"AUTH");
}

#stuff to do when we get authorized to rcon
sub rcon_authorized {
	logandprint ("- *RCON AUTHORIZED*\n","green");
	
	$rcon_logged_in = 1;
	sleep 1;

	# RCON GET STATUS
	sendcmd ("status");
}

#stuff to do when we are refused by rcon
sub rcon_not_authorized {
	logandprint ("- *RCON -NOT- AUTHORIZED*\n","red");
	socket_disconnect();
	die "Bad password?\n";
}

# GET ANY INCOMING SOCKET DATA AND PROCESS IT
sub process_server_messages {
	# get any waiting data
	$inbuffer .= readsocket($socket);

	if ($inbuffer ne "") {
		# PARSE AND PROCESS INCOMING DATA, unprocessed data is returned back to us
		while (length($inbuffer) > 12) {
			$inbuffer = process_next_message_from_buffer ($inbuffer);
		}
	} else {
		#no data
	}
}

# PROCESS NEXT PACKET
# Pull the next message, out of the buffer, return the rest of the buffer back to the caller
# 
# $remainderbuffer = process_next_message_from_buffer ($buffer)
#
# returns: remainder of unprocessed data
#
sub process_next_message_from_buffer {
	my $message_buffer = "";
	my $packet_size = "";
	my $packet_id = "";
	my $packet_type = "";
	my $packet_type_text = "";
	my $buffer_body = "";
	my $packet_text = "";
	my $leftoverdata = "";

	$message_buffer = $_[0];
	# SEE IF WE HAVE TOO LITTLE DATA FOR A HEADER
	if (length($message_buffer) < 12) 
	{
		if (length($message_buffer) == 0) {
			return "";
		}
		print "not enough data yet (".length($message_buffer)." bytes : '$message_buffer'\n";
		return $message_buffer;
	}



	#get header details
	# 4 bytes size (not including size)
	# 4 bytes ID
	# 4 bytes packet type
	$packet_size = substr($message_buffer,0,4);
	$packet_id = substr($message_buffer,4,4);
	$packet_type = substr($message_buffer,8,4);

	#convert header data to usable numbers
	$packet_size = le32toint($packet_size);
	$packet_id = le32toint ($packet_id);
	$packet_type = le32toint ($packet_type); 

	if (length($message_buffer) < $packet_size + 4) {
		debugprint ("WARNING: Not enough data yet\n");
		return $message_buffer;
	}

	$packet_text = substr($message_buffer,10,$packet_size-8);

	$leftoverdata= substr($message_buffer,$packet_size+4,length($message_buffer)-($packet_size+4));


	if ($debug_enabled == 1) {
		if ($packet_type == 4) {
			$packet_type_text = "MSG";
		} elsif ($packet_type == 2) {
			$packet_type_text = "AUTH";
		} elsif ($packet_type == 0) {
			$packet_type_text = "RESPONSE";
		} else {
			$packet_type_text = "UNKNOWN";
		}
			
		
		debugprint ("Processing inbound packet: type: $packet_type (".str2hex(inttole32($packet_type)).") $packet_type_text  /  ID: $packet_id (". str2hex(inttole32($packet_id)).")\nMESSAGE: " . str2hex($packet_text)."\n");
	}


	#Packet type 0 - Discard it
	if ($packet_type == 0) {
		# tends to be dupe messages
		#process_incoming_text("---> $packet_text");
	}

	#Packet type 2 - Authorization Success
	elsif ($packet_type == 2) {
		if (str2hex(inttole32($packet_id)) eq "ffffffff" or $packet_id == 4294967295) {
			rcon_not_authorized();
		}
		else {
			rcon_authorized();
		}
	}

	#Packet type 4 - Display it
	elsif ($packet_type == 4) {

		#process the current data however we want
		process_incoming_text($packet_text);
	}
	else {
		#this probably shouldn't happen unless its connected to something besides Rust
		logandprint("*****************RCON CLIENT: Unhandled packet type: " . $packet_type . "\n","red");
		logandprint(str2hex($packet_text," "),"red");
		process_incoming_text($packet_text);
	}		

	#return the extra data so it can be processed later
	return $leftoverdata;
}

# process_user_input ()
# - See if we have anything to send from the user
sub process_user_input {
		# Nonblocking input check
	if ( $nb_stdin -> can_read(0) )	{
		$user_input_buffer = <STDIN>;
		chomp ($user_input_buffer);
		# Send command to the server
		sendcmd($user_input_buffer);
		$user_input_buffer = "";
 	}

}


# process_incoming_text ($text)
#   - All incoming text to be displayed or otherwise parsed comes here
sub process_incoming_text {
	my $data = $_[0];

	#get rid of any null characters in the text.  sometimes there are some
	$data =~ s/\x00//g;

	#add a carriage return at the end
	$data = $data . "\n";

	#log the text
	logdata($data);

	#lines starting with [RCON]
	if ($data =~ /^\[RCON\]/)
	{
		printcolor($data, "hwhite");
	}
	#lines starting with [Oxide]
	elsif ($data =~ /^\[Oxide\]/) 
	{
		if ($data =~ /\[Error/) 
		{
			printcolor($data, "red");
		}
		elsif ($data =~ /\[Debug/) 
		{
			printcolor($data, "red");
		}
	}
	elsif ($data =~ /^\[CHAT\]/) 
	{
		printcolor ($data,"hcyan");
	}
	elsif ($data =~ /was killed by/) 
	{
		printcolor($data, "yellow");
	}


	elsif ($data =~ /^[0-9].*joined/) 
	{
		printcolor($data, "hgreen");
	}		
	elsif ($data =~ /^[0-9].*kicked\: Steam/) 
	{
		printcolor($data, "green");
	}		
	elsif ($data =~ /^[0-9].*disconnecting/) 
	{
		printcolor($data, "green");
	}		
	#anything else just print it
	else 
	{
		#print "No match for: $data\n".str2hex($data)."\n";
		printcolor ($data);
	}
}

sub logandprint {
	my $data = shift;
	my $color = shift;
	printcolor ($data, $color);
	logdata ($data);
}
	
sub logdata {
	my $data = shift;

	if ($logging_enabled == 1) {
		if ($logging_timestamp_enabled == 1) {
			print $logfilefh rcon_timestamp() . "$data";
		}
		else
		{
			print $logfilefh "$data";
		}

		$logfilefh->flush;
	}
}

# sendauth ($password)
#   - sends authorization packet to the server
sub sendauth {
	sendcmd($_[0],"AUTH");
}


# sendcmd ($command)
# sendcmd ($command, ["AUTH" if auth packet)
#   - sends a command to the server
sub sendcmd {
	my ($sendcmd) = $_[0];
	my ($packet) = "";
	$packet = makepacket ($sendcmd, $_[1]);

	# debugprint (str2hex($packet," ") ."\n");

	writesocket ($packet)
}

# writesocket ($packet)
#   - send the packet to the server
sub writesocket {
	my $sockhandle = $socket;
	my $packet = $_[0];

	if ($debug_enabled == 1) {
		debugprint ("WRITESOCKET: " . str2hex($packet) . "\n");
	}

	#print "WRITESOCKET: (".length($packet)." bytes) data: $packet hex: ".str2hex($packet," ")."\n";
	syswrite ($sockhandle, $packet, length($packet));
	$sockhandle->flush;
}

# $data = readsocket();
#   - gets any data from the server and returns it
sub readsocket {
	my $sockhandle = $socket;
	my $rb = "";
	my $data = "";
	my $bytelen = "";

	$rb = sysread($sockhandle,$data,4096);

	if (defined $rb) {
		if ($rb > 0) {
			#if ($debug_enabled == 1) {
			#	debugprint ("READSOCKET: got $rb bytes\nREADSOCKET TEXT: " . $data. "\nREADSOCKET HEX:" . str2hex($data) . "\n");
			#}
			return $data;

		}
		else {
			#Probably disconnected
			logandprint("-Remote Connection closed\n","red");
			handle_client_disconnected();
			return "";
			
		}
	} else {

		# if error is just due to no data, that's fine
		if ($! == EWOULDBLOCK) {
		#no data
		 return "";
		}


		# if error is something else, assume we got a connection drop
		$client_connected = 0;
		logandprint ("- Connection dropped.\n","red");
		handle_client_disconnected();
		return "";
	}
}

# Form a packet to be sent
# makepacket (command, ["AUTH" if auth packet])
sub makepacket {
	my ($packet_cmd);
	my ($packet_size);
	my ($packet);
	my ($packet_type);

	$packet_cmd = $_[0];
	$packet_size = length($packet_cmd);

	
	if ($_[1] eq "AUTH") {
		# auth packet
		$packet_type = 3;
	} else {
		# otherwise command packet
		$packet_type = 2;
	}

	# packet size = size of everything in the packet EXCEPT the packet size, so we add 4b for request id, 4b for request type, and 2b for the end terminators
	$packet_size = length($packet_cmd)+10;

	# byte 0-3: packet size
	$packet = inttole32($packet_size);

	# byte 4-7: request id, can be anything, but server response will have the same request ID
	$packet .= chr(1) . chr(2) . chr(3) . chr(4);

	# byte 8-11: request type (type 2 = normal command, type 3 = authorization request)
	$packet .= chr($packet_type) . chr(0) . chr(0) . chr(0);

	# bytes 12 thru ?? - message
	$packet .= $packet_cmd;

	# double nulls for terminator
	$packet .= chr(0);
	$packet .= chr(0);

	# send back the 
	return ($packet);
}

# Convert integer to 4 little endian bytes
sub inttole32 {
	my $data = $_[0];
	my $returnvalue = "";
	my $i1 = "";
	if ($data ne 0) {
		$i1 = int($data/16777216);
		$returnvalue = chr($i1); #byte 4
		$data = $data - ($i1*16777216);
		if ($data ne 0) {
			$i1 = int($data/65536);
			$returnvalue = chr($i1) . $returnvalue; #byte 3
			$data = $data - ($i1*65536);
				if ($data ne 0) {
					$i1 = int($data / 256);
					$returnvalue = chr($i1) . $returnvalue; # byte 2
					$data = $data - ($i1*256);
					$returnvalue = chr ($data) . $returnvalue; #byte 1
				}
				else {
					$returnvalue = chr(0) . chr (0) . $returnvalue;
				}



		}
		else {
			$returnvalue = chr(0) . chr(0) . chr (0) . $returnvalue;
		}
	}
	else {
		$returnvalue = chr(0) . chr(0) . chr(0) . chr(0);
	}
	if (length($returnvalue) != 4) {
		print "inttole32 calculation failure: " . $_[0] . " -> " . str2hex($returnvalue) . "\n";

		print length($returnvalue)."\n";
		die;
	}
	#debugprint ("inttole32: " . $_[0] . " -> " . str2hex($returnvalue) . "\n");
	return $returnvalue;
}

# Convert 4 little endian bytes to an integer
sub le32toint 
{
	my $data = $_[0];
	my $returnvalue = 0;
	$returnvalue = ord(substr($data,0,1)) + ord(substr ($data,1,1)) * 256 + ord(substr ($data,2,1)) * 65536 + ord(substr ($data,3,1)) * 16777216;
	return $returnvalue;
}



# CONVERT STRING TO HEX
sub str2hex 
{
	my $string = "";
	my $char = "";
	my $hex = "";
	my $returnstring="";
	my $separator = "";
	$string = $_[0];
	
	if (defined $_[1]) 
	{
		$separator = $_[1];
	}

	foreach $char (split //, $string) 
	{
		$hex = sprintf("%x", ord($char));
		if (length($hex) == 1) 
		{
			$hex = "0" . $hex;
		}
		$returnstring .= $hex . $separator;
	}
	return $returnstring;
}

sub debugprint 
{
	if ($debug_enabled == 1) 
	{
		logandprint ($_[0],"reverse");
	}
}

sub rcon_timestamp 
{

 my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
    return sprintf ( "%04d-%02d-%02d %02d:%02d:%02d: ",
                                   $year+1900,$mon+1,$mday,$hour,$min,$sec);

}

# printcolor (text, [color])
sub printcolor 
{
	my $text = shift;
	my $color = shift;

	#handle color off (print optional timestamp, and text
	if ($ansi_enabled == 0) 
	{
		#only adding the timestamp now if no color
		if ($console_timestamp_enabled == 1) 
		{
			$text = rcon_timestamp() . $text;
		}
		print $text;
		return;
	}


	elsif ($color ne "") 
	{
		if ($ansi{$color} eq "") 
		{
			print "Color not defined '$color'\n";
		}

		$text = $ansi{$color} . $text;

	}

	#start by text clearing any reverse background, change to white
	$text = $ansi{'white'} . $text;


	
	if ($console_timestamp_enabled == 1) 
	{
		$text = $ansi{'white'}.rcon_timestamp() . $text;
	}

	print $text . $ansi{'white'};

}
